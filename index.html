<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ÙˆÙ‚Ø¹ Ø¨Ø±Ø§Ø¹Ù… Ø¬ÙˆØ¬Ùˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ø¬Ø³Ù… ÙˆØ§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…ØªØ¯Ø±Ø¬Ø© Ø§Ù„Ø¯Ø§ÙØ¦Ø© ÙˆØ§Ù„Ø¯Ø§ÙƒÙ†Ø© */
        body {
            font-family: 'Cairo', sans-serif;
            background: linear-gradient(135deg, #332e40, #221c27); /* Ù„ÙˆÙ† Ø¨Ù†ÙØ³Ø¬ÙŠ Ø¯Ø§ÙƒÙ† Ù…Ø§Ø¦Ù„ Ù„Ù„Ø±Ù…Ø§Ø¯ÙŠØŒ Ø­Ù†ÙˆÙ† ÙˆØ«Ø§Ø¨Øª */
            display: flex;
            flex-direction: column; /* Allow content to stack vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure background covers full viewport height */
            margin: 0;
            position: relative; /* Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ø§Ù„Ø®Ù„ÙÙŠØ© ØªØªÙ…ÙˆØ¶Ø¹ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø¬Ø³Ù… */
            padding-bottom: 3rem; /* Add some padding at the bottom for scrolling content */
            padding-top: 2rem; /* Add some padding at the top */
        }
        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨ØªØµÙ…ÙŠÙ… Ù†Ø§Ø¹Ù… ÙˆÙ…Ø³ØªØ¯ÙŠØ± ÙˆØ¯Ø§ÙƒÙ† */
        .container {
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 100%; /* Ensure it takes full width within max-width */
            position: relative;
            z-index: 10; /* ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙÙˆÙ‚ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© */
            overflow: hidden; /* Keep overflow hidden for the container itself */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        /* ØªØµÙ…ÙŠÙ… Ù†Øµ "ØªÙ… ØªØµÙ…ÙŠÙ…Ù‡ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ù† Ø£Ø¬Ù„ Ø¬ÙˆØ¬Ùˆ" Ø¨Ù„ÙˆÙ† ÙØ§ØªØ­ ÙˆØªØ­Ø±ÙŠÙƒ Ø¹ØµØ±ÙŠ */
        .text-jojo {
            color: #f8bbd0;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1.3;
            animation: textGlowPulse 3s infinite alternate;
            text-shadow: 0 0 5px rgba(248, 187, 208, 0.5);
        }
        /* Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù‚Ù„Ø¨ Ù…Ø¹ ØªØ­Ø±ÙŠÙƒ Ù†Ø¨Ø¶ Ù„Ø·ÙŠÙ */
        .heart-icon {
            display: inline-block;
            color: #f8bbd0;
            margin-left: 0.5rem;
            /* ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ø¨Ø¶ Ù„Ù„Ù‚Ù„Ø¨ ÙŠØªÙ… Ø¯Ù…Ø¬Ù‡ Ù…Ø¹ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Øµ */
        }

        /* ØªØµÙ…ÙŠÙ… Ù†Øµ "Ù†ÙˆÙ… Ø§Ù„Ù‡Ù†Ø§ ÙˆØ§Ù„Ø¹Ø§ÙÙŠØ©" */
        .text-jojo-sub {
            color: #e0f7fa;
            font-size: 1.5rem;
            font-weight: 400;
            margin-top: 0;
            margin-bottom: 2rem;
            line-height: 1.2;
        }

        /* Ø£ÙŠÙ‚ÙˆÙ†Ø© Zzz Ù…Ø¹ ØªØ­Ø±ÙŠÙƒ Ù„Ø·ÙŠÙ */
        .zzz-icon {
            display: inline-block;
            color: #e0f7fa;
            margin-left: 0.5rem;
            font-size: 1.8rem;
            animation: zzzFloat 2s infinite alternate ease-in-out;
        }

        /* Ù‚Ù„ÙˆØ¨ Ø®Ù„ÙÙŠØ© Ù…ØªØ­Ø±ÙƒØ© - Ø§Ù„Ø¢Ù† Ø¹Ù„Ù‰ ÙƒØ§Ù…Ù„ Ø§Ù„Ø´Ø§Ø´Ø© */
        .heart-shape {
            position: absolute; /* ØªÙ…ÙˆØ¶Ø¹ Ù…Ø·Ù„Ù‚ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø¬Ø³Ù… */
            background-color: rgba(255, 255, 255, 0.1); /* Ù„ÙˆÙ† Ø£Ø¨ÙŠØ¶ Ø´ÙØ§Ù Ø£ÙƒØ«Ø± Ø®ÙÙˆØªØ§Ù‹ */
            border-radius: 50%;
            animation: pulseHeart 6s infinite ease-in-out; /* Ø­Ø±ÙƒØ© Ù†Ø¨Ø¶ Ø£Ø¨Ø·Ø£ Ù„Ù„Ù‚Ù„ÙˆØ¨ */
            opacity: 0;
            z-index: 0; /* ØªÙƒÙˆÙ† Ø®Ù„Ù Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ */
            filter: blur(7px); /* ØªØ£Ø«ÙŠØ± Ø¶Ø¨Ø§Ø¨ÙŠ Ø£ÙƒØ«Ø± Ù„Ù…Ø¸Ù‡Ø± Ø£ÙƒØ«Ø± Ù†Ø¹ÙˆÙ…Ø© ÙˆØ®ÙÙˆØª */
        }
        /* Ø´ÙƒÙ„ Ø§Ù„Ù‚Ù„Ø¨ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pseudo-elements */
        .heart-shape::before,
        .heart-shape::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: inherit; /* ÙŠØ±Ø« Ù„ÙˆÙ† Ø§Ù„Ù‚Ù„Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ */
            border-radius: 50%;
        }
        .heart-shape::before {
            top: -50%;
            left: 0;
        }
        .heart-shape::after {
            top: 0;
            left: 50%;
            transform: rotate(90deg);
            transform-origin: 0% 100%;
        }

        /* Ø®ØµØ§Ø¦Øµ Ù„ÙƒÙ„ Ù‚Ù„Ø¨ Ù„ØªØ­Ø±ÙŠÙƒ ÙˆØªÙ…ÙˆØ¶Ø¹ Ù…Ø®ØªÙ„Ù Ø¹Ù„Ù‰ ÙƒØ§Ù…Ù„ Ø§Ù„Ø´Ø§Ø´Ø© */
        .heart-shape:nth-child(1) {
            width: 80px; height: 80px;
            top: 10%; left: 15%;
            animation-delay: 0s;
            transform: rotate(-20deg);
        }
        .heart-shape:nth-child(2) {
            width: 100px; height: 100px;
            bottom: 5%; right: 10%;
            animation-delay: 1s;
            transform: rotate(30deg);
        }
        .heart-shape:nth-child(3) {
            width: 60px; height: 60px;
            top: 50%; left: 5%;
            animation-delay: 2s;
            transform: rotate(10deg);
        }
        .heart-shape:nth-child(4) {
            width: 90px; height: 90px;
            top: 20%; right: 25%;
            animation-delay: 3s;
            transform: rotate(-40deg);
        }
        .heart-shape:nth-child(5) {
            width: 70px; height: 70px;
            bottom: 20%; left: 30%;
            animation-delay: 0.5s;
            background-color: rgba(255, 204, 229, 0.1);
            transform: rotate(50deg);
        }
        .heart-shape:nth-child(6) {
            width: 50px; height: 50px;
            top: 40%; right: 5%;
            animation-delay: 2.5s;
            background-color: rgba(179, 229, 252, 0.1);
            transform: rotate(-10deg);
        }
        /* Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚Ù„ÙˆØ¨ Ù„ØªØºØ·ÙŠØ© Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø´ÙƒÙ„ Ø£ÙØ¶Ù„ */
        .heart-shape:nth-child(7) {
            width: 75px; height: 75px;
            top: 70%; left: 18%;
            animation-delay: 4s;
            transform: rotate(15deg);
        }
        .heart-shape:nth-child(8) {
            width: 85px; height: 85px;
            top: 5%; right: 50%;
            animation-delay: 1.5s;
            transform: rotate(-35deg);
        }
        .heart-shape:nth-child(9) {
            width: 65px; height: 65px;
            bottom: 10%; left: 45%;
            animation-delay: 3.5s;
            transform: rotate(25deg);
        }

        /* ØªØ¹Ø±ÙŠÙ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ø¨Ø¶ Ù„Ù„Ù‚Ù„ÙˆØ¨ */
        @keyframes pulseHeart {
            0% {
                transform: scale(0) rotate(var(--rotation, 0deg));
                opacity: 0;
            }
            50% {
                transform: scale(1) rotate(var(--rotation, 0deg));
                opacity: 0.15;
            }
            100% {
                transform: scale(0) rotate(var(--rotation, 0deg));
                opacity: 0;
            }
        }

        /* ØªØ¹Ø±ÙŠÙ ØªØ­Ø±ÙŠÙƒ Ù†Ø¨Ø¶ Ø§Ù„Ù‚Ù„Ø¨ (Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ØµØºÙŠØ±Ø©) */
        @keyframes beat {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        /* ØªØ­Ø±ÙŠÙƒ ØªÙˆÙ‡Ø¬ ÙˆÙ†Ø¨Ø¶ Ø§Ù„Ù†Øµ (textGlowPulse) */
        @keyframes textGlowPulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 5px rgba(248, 187, 208, 0.5);
            }
            50% {
                transform: scale(1.02);
                text-shadow: 0 0 15px rgba(248, 187, 208, 0.8), 0 0 25px rgba(248, 187, 208, 0.3);
            }
            100% {
                transform: scale(1);
                text-shadow: 0 0 5px rgba(248, 187, 208, 0.5);
            }
        }

        /* ØªØ­Ø±ÙŠÙƒ Ø·ÙÙˆ Zzz */
        @keyframes zzzFloat {
            0% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(-8px); opacity: 0.7; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* ØªØµÙ…ÙŠÙ… Ø²Ø± Ø§Ù„ØªØ´ØºÙŠÙ„ */
        .play-button {
            background-color: #7e57c2;
            color: white;
            padding: 1rem 2rem;
            border-radius: 9999px;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2rem;
            border: none;
        }
        .play-button:hover {
            background-color: #673ab7;
            transform: translateY(-2px);
        }
        .play-button:active {
            transform: translateY(0);
        }
        .play-icon {
            margin-left: 0.75rem;
            font-size: 1.8rem;
        }

        /* Ø£Ù†Ù…Ø§Ø· Ø®Ø§ØµØ© Ø¨Ù…ÙŠØ²Ø§Øª Gemini API */
        .gemini-feature-section {
            background-color: rgba(255, 255, 255, 0.08); /* Ø®Ù„ÙÙŠØ© Ø®Ø§ÙØªØ© Ù„Ù„Ù‚Ø³Ù… */
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 2.5rem;
            width: 100%;
            max-width: 500px; /* ØªØ­Ø¯ÙŠØ¯ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ Ù„Ù„Ù‚Ø³Ù… */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .gemini-feature-section h2 {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .gemini-feature-section textarea,
        .gemini-feature-section input[type="text"] {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.15); /* Ø®Ù„ÙÙŠØ© Ø®Ø§ÙØªØ© Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù†Øµ */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.75rem;
            padding: 0.75rem;
            color: #e0f7fa; /* Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø§Ù„ÙØ§ØªØ­ */
            font-size: 1rem;
            resize: vertical; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù†Øµ Ø¹Ù…ÙˆØ¯ÙŠØ§Ù‹ */
            min-height: 80px;
            outline: none; /* Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¥Ø·Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„ØªØ±ÙƒÙŠØ² */
            transition: border-color 0.3s ease;
            margin-bottom: 1rem;
        }
        .gemini-feature-section input[type="text"] {
            min-height: auto; /* Override min-height for single-line input */
        }
        .gemini-feature-section textarea:focus,
        .gemini-feature-section input[type="text"]:focus {
            border-color: #f8bbd0; /* Ù„ÙˆÙ† ÙˆØ±Ø¯ÙŠ Ø¹Ù†Ø¯ Ø§Ù„ØªØ±ÙƒÙŠØ² */
        }
        .gemini-feature-section button {
            background-color: #f8bbd0; /* Ù„ÙˆÙ† ÙˆØ±Ø¯ÙŠ Ù„Ù„Ø²Ø± */
            color: #332e40; /* Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø§Ù„Ø¯Ø§ÙƒÙ† */
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 0.5rem;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gemini-feature-section button:hover {
            background-color: #f48fb1; /* Ù„ÙˆÙ† ÙˆØ±Ø¯ÙŠ Ø£ØºÙ…Ù‚ Ø¹Ù†Ø¯ Ø§Ù„ØªÙ…Ø±ÙŠØ± */
            transform: translateY(-2px);
        }
        .gemini-feature-section button:active {
            transform: translateY(0);
        }
        .gemini-output {
            background-color: rgba(255, 255, 255, 0.05); /* Ø®Ù„ÙÙŠØ© Ø£ØºÙ…Ù‚ Ù„Ù„Ù‚ØµØ© */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1.5rem;
            color: #e0f7fa; /* Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø§Ù„ÙØ§ØªØ­ */
            font-size: 1rem;
            text-align: right; /* Ù…Ø­Ø§Ø°Ø§Ø© Ø§Ù„Ù†Øµ Ù„Ù„ÙŠÙ…ÙŠÙ† */
            line-height: 1.6;
            max-height: 250px; /* Ø£Ù‚ØµÙ‰ Ø§Ø±ØªÙØ§Ø¹ Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‚ØµØ© */
            overflow-y: auto; /* Ø¥Ø¶Ø§ÙØ© Ø´Ø±ÙŠØ· ØªÙ…Ø±ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ØµØ© Ø·ÙˆÙŠÙ„Ø© */
            white-space: pre-wrap; /* Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ ÙˆØ§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
            width: 100%;
        }
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #f8bbd0;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .loading-indicator .spinner {
            border: 4px solid rgba(248, 187, 208, 0.3);
            border-top: 4px solid #f8bbd0;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-left: 0.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Ø£Ù†Ù…Ø§Ø· Ø²Ø± Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ù‚ØµØ© */
        .listen-button {
            background-color: #81c784; /* Ù„ÙˆÙ† Ø£Ø®Ø¶Ø± Ù„Ø·ÙŠÙ */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 1rem;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .listen-button:hover {
            background-color: #66bb6a;
            transform: translateY(-2px);
        }
        .listen-button:active {
            transform: translateY(0);
        }
        .listen-icon {
            margin-left: 0.5rem;
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù‚Ø³Ù… Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ */
        .games-section {
            background-color: rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 2.5rem;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .games-section h2 {
            color: #b3e5fc; /* Ù„ÙˆÙ† Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ù„Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† */
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 5px rgba(179, 229, 252, 0.5);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© X-O (Tic-Tac-Toe) */
        .tic-tac-toe-game {
            margin-bottom: 2rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .tic-tac-toe-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .tic-tac-toe-board {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            padding: 5px;
        }
        .tic-tac-toe-cell {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: 700;
            cursor: pointer;
            color: #f8bbd0; /* Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ X */
            transition: background-color 0.2s ease;
        }
        .tic-tac-toe-cell.o {
            color: #81c784; /* Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ O */
        }
        .tic-tac-toe-cell:hover {
            background-color: rgba(255, 255, 255, 0.25);
        }
        .tic-tac-toe-reset-button {
            background-color: #7e57c2;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 1rem;
            border: none;
        }
        .tic-tac-toe-reset-button:hover {
            background-color: #673ab7;
            transform: translateY(-2px);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© Ø­Ø¬Ø± ÙˆØ±Ù‚Ø© Ù…Ù‚Øµ (Rock-Paper-Scissors) */
        .rps-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem; /* Add margin to separate from next game */
        }
        .rps-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .rps-choices {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .rps-choice-button {
            background-color: #f8bbd0;
            color: #332e40;
            padding: 1rem 1.5rem;
            border-radius: 1rem;
            font-size: 2rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .rps-choice-button:hover {
            background-color: #f48fb1;
            transform: translateY(-3px);
        }
        .rps-choice-button:active {
            transform: translateY(0);
        }
        .rps-result {
            color: #e0f7fa;
            font-size: 1.2rem;
            font-weight: 700;
            min-height: 30px; /* Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø­ØªÙ‰ Ù„Ùˆ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù†Øµ */
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø±Ù‚Ù… (Guess the Number) */
        .guess-number-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }
        .guess-number-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .guess-number-game input[type="number"] {
            width: 100px;
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.75rem;
            padding: 0.5rem;
            color: #e0f7fa;
            font-size: 1.2rem;
            text-align: center;
            outline: none;
            transition: border-color 0.3s ease;
            margin-bottom: 1rem;
        }
        .guess-number-game input[type="number"]:focus {
            border-color: #b3e5fc;
        }
        .guess-number-game button {
            background-color: #b3e5fc; /* Ù„ÙˆÙ† Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ù„Ù„Ø²Ø± */
            color: #332e40;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
        }
        .guess-number-game button:hover {
            background-color: #81d4fa;
            transform: translateY(-2px);
        }
        .guess-number-game button:active {
            transform: translateY(0);
        }
        .guess-number-game .message {
            color: #e0f7fa;
            font-size: 1.1rem;
            min-height: 25px; /* Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø­Ø© */
        }
        .guess-number-game .reset-button {
            background-color: #7e57c2;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 1rem;
            border: none;
        }
        .guess-number-game .reset-button:hover {
            background-color: #673ab7;
            transform: translateY(-2px);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© (Memory Match) */
        .memory-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }
        .memory-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 70px); /* 4 Ø£Ø¹Ù…Ø¯Ø© */
            grid-template-rows: repeat(4, 70px); /* 4 ØµÙÙˆÙ */
            gap: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 10px;
            max-width: 320px; /* (70*4) + (10*3) + (10*2) = 280 + 30 + 20 = 330px, adjusted for padding */
        }
        .memory-card {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 0.75rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: transform 0.3s ease, background-color 0.3s ease;
            transform-style: preserve-3d; /* Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø¹Ù†Ø¯ Ø§Ù„ØªÙ‚Ù„ÙŠØ¨ */
            position: relative;
        }
        .memory-card.flipped {
            transform: rotateY(180deg);
            background-color: rgba(255, 255, 255, 0.25);
        }
        .memory-card.matched {
            background-color: #81c784; /* Ù„ÙˆÙ† Ø£Ø®Ø¶Ø± Ù„Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© */
            cursor: default;
            opacity: 0.8;
        }
        .memory-card .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙˆØ¬Ù‡ Ø§Ù„Ø®Ù„ÙÙŠ Ø¹Ù†Ø¯ Ø¹Ø¯Ù… Ø§Ù„ØªÙ‚Ù„ÙŠØ¨ */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .memory-card .card-front {
            transform: rotateY(180deg); /* Ø§Ù„ÙˆØ¬Ù‡ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠ ÙŠØ¸Ù‡Ø± Ø¹Ù†Ø¯ Ø§Ù„ØªÙ‚Ù„ÙŠØ¨ */
        }
        .memory-card .card-back {
            background-color: #7e57c2; /* Ù„ÙˆÙ† Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© */
            border-radius: 0.75rem;
        }
        .memory-status {
            color: #e0f7fa;
            font-size: 1.1rem;
            margin-top: 1rem;
            min-height: 25px;
        }
        .memory-reset-button {
            background-color: #7e57c2;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 1rem;
            border: none;
        }
        .memory-reset-button:hover {
            background-color: #673ab7;
            transform: translateY(-2px);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© Ø§Ø¶Ø±Ø¨ Ø§Ù„Ø®Ù„Ø¯ (Whack-a-Mole) */
        .whack-a-mole-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }
        .whack-a-mole-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .whack-a-mole-grid {
            display: grid;
            grid-template-columns: repeat(3, 100px); /* 3 Ø£Ø¹Ù…Ø¯Ø© */
            grid-template-rows: repeat(3, 100px); /* 3 ØµÙÙˆÙ */
            gap: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 15px;
            max-width: 360px; /* (100*3) + (15*2) + (15*2) = 300 + 30 + 30 = 360px */
        }
        .mole-hole {
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%; /* Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ø±ÙŠ Ù„Ù„Ø­ÙØ±Ø© */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .mole-emoji {
            font-size: 3.5rem;
            position: absolute;
            bottom: -100%; /* ÙŠØ¨Ø¯Ø£ Ù…Ø®ÙÙŠÙ‹Ø§ ØªØ­Øª Ø§Ù„Ø­ÙØ±Ø© */
            transition: bottom 0.2s ease-out;
            cursor: pointer;
        }
        .mole-emoji.up {
            bottom: 0; /* ÙŠØ¸Ù‡Ø± ÙÙˆÙ‚ Ø§Ù„Ø­ÙØ±Ø© */
        }
        .whack-a-mole-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .whack-a-mole-button {
            background-color: #f8bbd0;
            color: #332e40;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
        }
        .whack-a-mole-button:hover {
            background-color: #f48fb1;
            transform: translateY(-2px);
        }
        .whack-a-mole-button:active {
            transform: translateY(0);
        }
        .whack-a-mole-score, .whack-a-mole-time {
            color: #e0f7fa;
            font-size: 1.1rem;
            margin-top: 1rem;
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© ÙØ±Ù‚Ø¹Ø© Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª (Pop the Bubble) */
        .bubble-pop-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }
        .bubble-pop-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .bubble-area {
            width: 100%;
            height: 300px; /* Fixed height for the game area */
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            position: relative;
            overflow: hidden; /* Keep bubbles inside */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 1rem;
        }
        .bubble {
            position: absolute;
            background-color: rgba(179, 229, 252, 0.6); /* Ù„ÙˆÙ† Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ ÙˆØ´ÙØ§Ù */
            border-radius: 50%;
            cursor: pointer;
            animation: bubbleFloat 5s linear infinite;
            opacity: 0;
            transform: scale(0);
            transition: transform 0.1s ease-out; /* For pop effect */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem; /* Emoji size */
            color: #332e40;
            font-weight: bold;
        }
        .bubble:active {
            transform: scale(1.2); /* Pop effect */
        }
        @keyframes bubbleFloat {
            0% { bottom: -20%; opacity: 0; transform: scale(0.5); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { bottom: 120%; opacity: 0; transform: scale(0.5); }
        }
        .bubble-pop-score, .bubble-pop-time {
            color: #e0f7fa;
            font-size: 1.1rem;
            margin-top: 0.5rem;
        }
        .bubble-pop-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .bubble-pop-button {
            background-color: #b3e5fc;
            color: #332e40;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
        }
        .bubble-pop-button:hover {
            background-color: #81d4fa;
            transform: translateY(-2px);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ù„Ø¹Ø¨Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† (Color Match) */
        .color-match-game {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }
        .color-match-game h3 {
            color: #e0f7fa;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        .target-color-display {
            width: 120px;
            height: 120px;
            border-radius: 1rem;
            background-color: #ccc; /* Placeholder */
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease;
        }
        .color-choices-grid {
            display: grid;
            grid-template-columns: repeat(2, 100px); /* 2 columns */
            gap: 15px;
            margin-bottom: 1.5rem;
        }
        .color-choice-button {
            width: 100px;
            height: 100px;
            border-radius: 1rem;
            background-color: #eee; /* Placeholder */
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .color-choice-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .color-match-message {
            color: #e0f7fa;
            font-size: 1.1rem;
            min-height: 25px;
        }
        .color-match-score {
            color: #e0f7fa;
            font-size: 1.1rem;
            margin-top: 0.5rem;
        }
        .color-match-reset-button {
            background-color: #7e57c2;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 1rem;
            border: none;
        }
        .color-match-reset-button:hover {
            background-color: #673ab7;
            transform: translateY(-2px);
        }

        /* Ø£Ù†Ù…Ø§Ø· Ø®Ø§ØµØ© Ø¨Ø§Ù„ÙÙˆØªØ± */
        .footer {
            margin-top: 3rem;
            color: #e0f7fa;
            font-size: 1.2rem;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(224, 247, 250, 0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .footer .heart-icon-footer {
            color: #f8bbd0;
            font-size: 1.5rem;
            animation: beat 1s infinite alternate;
        }


        /* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ØªØ¬Ø§ÙˆØ¨ Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ØµØºØ± (Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ ÙˆØ§Ù„ØªØ§Ø¨Ù„Øª) */
        @media (max-width: 768px) {
            .text-jojo {
                font-size: 1.8rem;
            }
            .text-jojo-sub {
                font-size: 1.2rem;
            }
            .zzz-icon {
                font-size: 1.5rem;
            }
            .container {
                padding: 1.5rem;
                border-radius: 1.5rem;
            }
            .play-button {
                padding: 0.8rem 1.5rem;
                font-size: 1.2rem;
            }
            .play-icon {
                font-size: 1.5rem;
            }
            /* ØªÙ‚Ù„ÙŠÙ„ Ø£Ø­Ø¬Ø§Ù… Ø§Ù„Ù‚Ù„ÙˆØ¨ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
            .heart-shape:nth-child(1) { width: 50px; height: 50px; }
            .heart-shape:nth-child(2) { width: 70px; height: 70px; }
            .heart-shape:nth-child(3) { width: 30px; height: 30px; }
            .heart-shape:nth-child(4) { width: 60px; height: 60px; }
            .heart-shape:nth-child(5) { width: 40px; height: 40px; }
            .heart-shape:nth-child(6) { width: 25px; height: 25px; }
            .heart-shape:nth-child(7) { width: 55px; height: 55px; }
            .heart-shape:nth-child(8) { width: 65px; height: 65px; }
            .heart-shape:nth-child(9) { width: 45px; height: 45px; }

            .gemini-feature-section {
                padding: 1rem;
                margin-top: 2rem;
            }
            .gemini-feature-section textarea,
            .gemini-feature-section input[type="text"] {
                font-size: 0.9rem;
            }
            .gemini-feature-section button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }
            .gemini-output {
                font-size: 0.9rem;
            }
            .listen-button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }

            /* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
            .games-section {
                padding: 1rem;
                margin-top: 2rem;
            }
            .games-section h2 {
                font-size: 1.5rem;
            }
            .tic-tac-toe-board {
                grid-template-columns: repeat(3, 60px);
                grid-template-rows: repeat(3, 60px);
            }
            .tic-tac-toe-cell {
                width: 60px;
                height: 60px;
                font-size: 2.2rem;
            }
            .rps-choice-button {
                padding: 0.8rem 1.2rem;
                font-size: 1.5rem;
            }
            .rps-result {
                font-size: 1rem;
            }
            .guess-number-game input[type="number"] {
                width: 80px;
                font-size: 1rem;
            }
            .guess-number-game button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }
            .guess-number-game .message {
                font-size: 0.9rem;
            }
            /* Memory Game adjustments */
            .memory-grid {
                grid-template-columns: repeat(4, 55px);
                grid-template-rows: repeat(4, 55px);
                gap: 8px;
                max-width: 260px; /* (55*4) + (8*3) + (8*2) = 220 + 24 + 16 = 260px */
            }
            .memory-card {
                width: 55px;
                height: 55px;
                font-size: 2rem;
            }
            /* Whack-a-Mole adjustments */
            .whack-a-mole-grid {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
                gap: 10px;
                max-width: 270px; /* (80*3) + (10*2) + (10*2) = 240 + 20 + 20 = 280px */
            }
            .mole-hole {
                width: 80px;
                height: 80px;
            }
            .mole-emoji {
                font-size: 2.8rem;
            }
            .whack-a-mole-button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }
            .whack-a-mole-score, .whack-a-mole-time {
                font-size: 1rem;
            }
            /* Bubble Pop adjustments */
            .bubble-area {
                height: 250px;
            }
            .bubble {
                font-size: 1.2rem;
            }
            .bubble-pop-button {
                font-size: 1rem;
                padding: 0.6rem 1.2rem;
            }
            /* Color Match adjustments */
            .target-color-display {
                width: 100px;
                height: 100px;
            }
            .color-choices-grid {
                grid-template-columns: repeat(2, 80px);
                gap: 10px;
            }
            .color-choice-button {
                width: 80px;
                height: 80px;
            }
            .footer {
                font-size: 1rem;
            }
            .footer .heart-icon-footer {
                font-size: 1.2rem;
            }
        }
        /* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ØªØ¬Ø§ÙˆØ¨ Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ØµØºØ± Ø¬Ø¯Ø§Ù‹ (Ø§Ù„Ù‡ÙˆØ§ØªÙ) */
        @media (max-width: 480px) {
            .text-jojo {
                font-size: 1.5rem;
            }
            .text-jojo-sub {
                font-size: 1rem;
            }
            .zzz-icon {
                font-size: 1.2rem;
            }
            .container {
                padding: 1rem;
                border-radius: 1rem;
            }
            /* Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù‚Ù„ÙˆØ¨ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§Ø²Ø¯Ø­Ø§Ù… Ø§Ù„Ø´Ø¯ÙŠØ¯ */
            .heart-shape {
                display: none;
            }
            .gemini-feature-section {
                padding: 0.8rem;
                margin-top: 1.5rem;
            }
            /* ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø®Ù„Ø§ÙŠØ§ X-O Ø£ÙƒØ«Ø± */
            .tic-tac-toe-board {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
            }
            .tic-tac-toe-cell {
                width: 50px;
                height: 50px;
                font-size: 1.8rem;
            }
            .rps-choices {
                flex-direction: column; /* Ø¬Ø¹Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¹Ù…ÙˆØ¯ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ */
                gap: 0.8rem;
            }
            /* Memory Game adjustments for very small screens */
            .memory-grid {
                grid-template-columns: repeat(4, 45px);
                grid-template-rows: repeat(4, 45px);
                gap: 5px;
                max-width: 200px; /* (45*4) + (5*3) + (5*2) = 180 + 15 + 10 = 205px */
            }
            .memory-card {
                width: 45px;
                height: 45px;
                font-size: 1.8rem;
            }
            /* Whack-a-Mole adjustments for very small screens */
            .whack-a-mole-grid {
                grid-template-columns: repeat(3, 60px);
                grid-template-rows: repeat(3, 60px);
                gap: 8px;
                max-width: 200px; /* (60*3) + (8*2) + (8*2) = 180 + 16 + 16 = 212px */
            }
            .mole-hole {
                width: 60px;
                height: 60px;
            }
            .mole-emoji {
                font-size: 2.2rem;
            }
            /* Bubble Pop adjustments */
            .bubble-area {
                height: 200px;
            }
            .bubble {
                font-size: 1rem;
            }
            /* Color Match adjustments */
            .target-color-display {
                width: 80px;
                height: 80px;
            }
            .color-choices-grid {
                grid-template-columns: repeat(2, 60px);
                gap: 8px;
            }
            .color-choice-button {
                width: 60px;
                height: 60px;
            }
            .footer {
                font-size: 0.9rem;
            }
            .footer .heart-icon-footer {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="heart-shape" style="top: 10%; left: 15%; --rotation: -20deg;"></div>
    <div class="heart-shape" style="bottom: 5%; right: 10%; --rotation: 30deg;"></div>
    <div class="heart-shape" style="top: 50%; left: 5%; --rotation: 10deg;"></div>
    <div class="heart-shape" style="top: 20%; right: 25%; --rotation: -40deg;"></div>
    <div class="heart-shape" style="bottom: 20%; left: 30%; --rotation: 50deg;"></div>
    <div class="heart-shape" style="top: 40%; right: 5%; --rotation: -10deg;"></div>
    <div class="heart-shape" style="top: 70%; left: 18%; --rotation: 15deg;"></div>
    <div class="heart-shape" style="top: 5%; right: 50%; --rotation: -35deg;"></div>
    <div class="heart-shape" style="bottom: 10%; left: 45%; --rotation: 25deg;"></div>

    <div class="container">
        <h1 class="text-jojo">
            Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ØµÙÙ…Ù‘Ù… Ø®ØµÙŠØµÙ‹Ø§ Ù„Ø¬ÙˆØ¬Ùˆ <span class="heart-icon">â¤ï¸</span>
        </h1>
        <p class="text-jojo-sub">
            Ù†ÙˆÙ… Ø§Ù„Ø¹ÙˆØ§ÙÙŠ <span class="zzz-icon">Zzz</span>
        </p>

        <div id="audioPrompt" class="flex flex-col items-center justify-center">
            <p class="text-gray-300 text-lg mb-4">Ø§Ø¶ØºØ· Ù‡Ù†Ø§ Ù„ØªØ´ØºÙŠÙ„ Ø£ØºÙ†ÙŠØ© Ø¨Ø±Ø§Ø¹Ù…!</p>
            <button id="playButton" class="play-button">
                ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ©
                <svg class="play-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <p id="errorMessage" class="text-red-400 text-sm mt-2 hidden">
                Ø¹Ø°Ø±Ø§Ù‹ØŒ ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø±Ø§Ø¨Ø· Ø§Ù„Ø£ØºÙ†ÙŠØ© ØµØ­ÙŠØ­ ÙˆÙ…Ø¨Ø§Ø´Ø± (ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ .mp3).
            </p>
        </div>

        <audio id="baraemAudio" loop>
            <source src="https://archive.org/download/baraem-song/baraem-song.mp3" type="audio/mpeg">
            Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª.
        </audio>

        <div class="gemini-feature-section">
            <h2 class="text-pink-200 mb-4">âœ¨ ØªØ£Ù„ÙŠÙ Ø§Ù„Ù‚ØµØµ Ù„Ø¬ÙˆØ¬Ùˆ âœ¨</h2>
            <textarea id="storyPromptInput" placeholder="Ø§ÙƒØªØ¨ ÙÙƒØ±Ø© Ø§Ù„Ù‚ØµØ© Ù‡Ù†Ø§ (Ù…Ø«Ù„Ø§Ù‹: Ø¹Ù† Ø£Ø±Ù†Ø¨ ØµØºÙŠØ±ØŒ Ù†Ø¬Ù…Ø© ØªÙ„Ù…Ø¹)"></textarea>
            <button id="generateStoryButton">
                ØªØ£Ù„ÙŠÙ Ø§Ù„Ù‚ØµØ© âœ¨
            </button>
            <div id="storyLoadingIndicator" class="loading-indicator hidden">
                <div class="spinner"></div>
                <span class="mr-2">Ø¬Ø§Ø±ÙŠ ØªØ£Ù„ÙŠÙ Ø§Ù„Ù‚ØµØ©...</span>
            </div>
            <div id="storyOutput" class="gemini-output hidden"></div>
            <button id="listenStoryButton" class="listen-button hidden">
                Ø§Ø³ØªÙ…Ø¹ Ù„Ù„Ù‚ØµØ©
                <svg class="listen-icon w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.616 3.89a1 1 0 011.768 0 1 1 0 010 1.768l-1.768 1.768a1 1 0 01-1.768 0 1 1 0 010-1.768l2.5-2.5a1 1 0 010-1.414zM16.03 7.303a1 1 0 011.414 0 1 1 0 010 1.414L14.414 11l3.03 3.03a1 1 0 01-1.414 1.414L13 12.414l-3.03 3.03a1 1 0 01-1.414-1.414L11.586 11l-3.03-3.03a1 1 0 010-1.414 1 1 0 011.414 0L13 9.586l3.03-3.03z" clip-rule="evenodd"></path>
                </svg>
            </button>
        </div>

        <div class="gemini-feature-section">
            <h2 class="text-purple-200 mb-4">âœ¨ Ø§Ø³Ø£Ù„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ âœ¨</h2>
            <textarea id="aiQuestionInput" placeholder="Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§ (Ù…Ø«Ù„Ø§Ù‹: Ù„ÙŠØ´ Ø§Ù„Ø³Ù…Ø§ Ø²Ø±Ù‚Ø§ØŸØŒ ÙƒÙŠÙ ØªÙ†Ø§Ù… Ø§Ù„Ù‚Ø·Ø·ØŸ)"></textarea>
            <button id="askAiButton">
                Ø§Ø³Ø£Ù„ âœ¨
            </button>
            <div id="aiLoadingIndicator" class="loading-indicator hidden">
                <div class="spinner"></div>
                <span class="mr-2">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©...</span>
            </div>
            <div id="aiAnswerOutput" class="gemini-output hidden"></div>
        </div>

        <div class="games-section">
            <h2 class="text-blue-200 mb-4">ğŸ® Ø£Ù„Ø¹Ø§Ø¨ Ø¬ÙˆØ¬Ùˆ ğŸ®</h2>

            <div class="tic-tac-toe-game">
                <h3>Ù„Ø¹Ø¨Ø© Ø¥ÙƒØ³ Ø£Ùˆ</h3>
                <div id="ticTacToeBoard" class="tic-tac-toe-board">
                    <div class="tic-tac-toe-cell" data-cell-index="0"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="1"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="2"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="3"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="4"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="5"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="6"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="7"></div>
                    <div class="tic-tac-toe-cell" data-cell-index="8"></div>
                </div>
                <p id="ticTacToeStatus" class="text-e0f7fa mt-4 text-lg font-semibold">Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ X</p>
                <button id="ticTacToeResetButton" class="tic-tac-toe-reset-button">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>

            <div class="rps-game">
                <h3>Ù„Ø¹Ø¨Ø© Ø­Ø¬Ø± ÙˆØ±Ù‚Ø© Ù…Ù‚Øµ</h3>
                <div class="rps-choices">
                    <button class="rps-choice-button" data-choice="rock">âœŠ</button>
                    <button class="rps-choice-button" data-choice="paper">âœ‹</button>
                    <button class="rps-choice-button" data-choice="scissors">âœŒï¸</button>
                </div>
                <p id="rpsResult" class="rps-result"></p>
            </div>

            <div class="guess-number-game">
                <h3>Ù„Ø¹Ø¨Ø© ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø±Ù‚Ù… ğŸ”¢</h3>
                <p class="text-e0f7fa mb-2">Ø®Ù…Ù† Ø±Ù‚Ù… Ø¨ÙŠÙ† 1 Ùˆ 100.</p>
                <input type="number" id="guessInput" min="1" max="100" placeholder="Ø£Ø¯Ø®Ù„ ØªØ®Ù…ÙŠÙ†Ùƒ">
                <button id="guessButton">Ø®Ù…Ù†</button>
                <p id="guessMessage" class="message"></p>
                <p id="guessCount" class="text-e0f7fa text-sm mt-1">Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: 0</p>
                <button id="guessResetButton" class="reset-button">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>

            <div class="memory-game">
                <h3>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© ğŸ§ </h3>
                <p class="memory-status">Ù…Ø­Ø§ÙˆÙ„Ø§Øª: 0 | Ø£Ø²ÙˆØ§Ø¬ ØµØ­ÙŠØ­Ø©: 0</p>
                <div id="memoryGrid" class="memory-grid">
                    </div>
                <button id="memoryResetButton" class="memory-reset-button">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>

            <div class="whack-a-mole-game">
                <h3>Ù„Ø¹Ø¨Ø© Ø§Ø¶Ø±Ø¨ Ø§Ù„Ø±Ù…ÙˆØ² ğŸ’¥</h3>
                <p class="whack-a-mole-score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</p>
                <p class="whack-a-mole-time">Ø§Ù„ÙˆÙ‚Øª: 30 Ø«Ø§Ù†ÙŠØ©</p>
                <div id="whackAMoleGrid" class="whack-a-mole-grid">
                    </div>
                <div class="whack-a-mole-controls">
                    <button id="whackAMoleStartButton" class="whack-a-mole-button">Ø§Ø¨Ø¯Ø§ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                    <button id="whackAMoleResetButton" class="whack-a-mole-button hidden">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                </div>
            </div>

            <div class="bubble-pop-game">
                <h3>Ù„Ø¹Ø¨Ø© ÙØ±Ù‚Ø¹Ø© Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª ğŸ«§</h3>
                <p class="bubble-pop-score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</p>
                <p class="bubble-pop-time">Ø§Ù„ÙˆÙ‚Øª: 20 Ø«Ø§Ù†ÙŠØ©</p>
                <div id="bubbleArea" class="bubble-area">
                    </div>
                <div class="bubble-pop-controls">
                    <button id="bubblePopStartButton" class="bubble-pop-button">Ø§Ø¨Ø¯Ø§ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                    <button id="bubblePopResetButton" class="bubble-pop-button hidden">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                </div>
            </div>

            <div class="color-match-game">
                <h3>Ù„Ø¹Ø¨Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† ğŸ¨</h3>
                <p class="color-match-score">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</p>
                <div class="target-color-display" id="targetColorDisplay"></div>
                <div class="color-choices-grid" id="colorChoicesGrid">
                    </div>
                <p class="color-match-message" id="colorMatchMessage"></p>
                <button id="colorMatchResetButton" class="color-match-reset-button">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>

        </div>

    </div>

    <div class="footer">
        ØµÙ†Ø¹ Ø¨Ø­Ø¨ Ù…Ù† Ø£Ø¬Ù„Ùƒ <span class="heart-icon-footer">â¤ï¸</span>
    </div>

    <script>
        // Get references to audio elements and buttons
        const audio = document.getElementById('baraemAudio');
        const playButton = document.getElementById('playButton');
        const audioPrompt = document.getElementById('audioPrompt');
        const errorMessage = document.getElementById('errorMessage');

        // Get references to story generator elements
        const storyPromptInput = document.getElementById('storyPromptInput');
        const generateStoryButton = document.getElementById('generateStoryButton');
        const storyLoadingIndicator = document.getElementById('storyLoadingIndicator');
        const storyOutput = document.getElementById('storyOutput');
        const listenStoryButton = document.getElementById('listenStoryButton');

        // Get references to AI Q&A elements
        const aiQuestionInput = document.getElementById('aiQuestionInput');
        const askAiButton = document.getElementById('askAiButton');
        const aiLoadingIndicator = document.getElementById('aiLoadingIndicator');
        const aiAnswerOutput = document.getElementById('aiAnswerOutput');


        // Event listener for playing the audio
        playButton.addEventListener('click', () => {
            audio.play()
                .then(() => {
                    audioPrompt.style.display = 'none'; // Hide the audio prompt on successful play
                    errorMessage.classList.add('hidden'); // Hide any error message
                    console.log('ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª Ø¨Ù†Ø¬Ø§Ø­.'); // Log success
                })
                .catch(error => {
                    console.error('ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª:', error); // Log error if audio fails to play
                    errorMessage.classList.remove('hidden'); // Show error message to the user
                });
        });

        // Function to generate the story using Gemini API
        generateStoryButton.addEventListener('click', async () => {
            const promptText = storyPromptInput.value.trim();
            if (!promptText) {
                storyOutput.textContent = 'Ø§ÙƒØªØ¨ ÙÙƒØ±Ø© Ø§Ù„Ù‚ØµØ© Ø£ÙˆÙ„ Ø´ÙŠØ¡.'; // Prompt user for input
                storyOutput.classList.remove('hidden');
                listenStoryButton.classList.add('hidden'); // Hide listen button if no story
                return;
            }

            storyLoadingIndicator.classList.remove('hidden'); // Show loading indicator
            storyOutput.classList.add('hidden'); // Hide previous story output
            listenStoryButton.classList.add('hidden'); // Hide listen button during generation
            storyOutput.textContent = ''; // Clear any previous story

            try {
                let chatHistory = [];
                // Construct the prompt for the Gemini API
                chatHistory.push({ role: "user", parts: [{ text: `Ø§ÙƒØªØ¨ Ù‚ØµØ© Ù†ÙˆÙ… Ù‚ØµÙŠØ±Ø© ÙˆÙ‡Ø§Ø¯Ø¦Ø© ÙˆÙ„Ø·ÙŠÙØ© Ù„Ù„Ø£Ø·ÙØ§Ù„ Ø¹Ù†: ${promptText}. Ø§Ù„Ù‚ØµØ© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø£Ø·ÙØ§Ù„ Ø§Ù„ØµØºØ§Ø± ÙˆØªØ³Ø§Ø¹Ø¯Ù‡Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ±Ø®Ø§Ø¡ ÙˆØ§Ù„Ù†ÙˆÙ…. Ø§Ø¬Ø¹Ù„Ù‡Ø§ Ø­ÙˆØ§Ù„ÙŠ 100-150 ÙƒÙ„Ù…Ø©. Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ø£ÙŠ Ù…Ù‚Ø¯Ù…Ø§Øª Ø£Ùˆ Ø®Ø§ØªÙ…Ø§Øª Ù„Ù„Ù‚ØµØ©ØŒ ÙÙ‚Ø· Ù†Øµ Ø§Ù„Ù‚ØµØ©.` }] });
                const payload = { contents: chatHistory };
                // API key is left empty as it will be provided by the Canvas environment
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                // Check if the response contains valid content
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const story = result.candidates[0].content.parts[0].text;
                    storyOutput.textContent = story; // Display the generated story
                    storyOutput.classList.remove('hidden'); // Show the story output
                    listenStoryButton.classList.remove('hidden'); // Show listen button after successful generation
                } else {
                    storyOutput.textContent = 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù‚ØµØ©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©.'; // Error message for user
                    storyOutput.classList.remove('hidden');
                    listenStoryButton.classList.add('hidden'); // Hide listen button on failure
                    console.error('Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Gemini API:', result); // Log unexpected API response
                }
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Gemini API:', error); // Log API call error
                storyOutput.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù‚ØµØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ø£Ùˆ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.'; // Generic error message
                storyOutput.classList.remove('hidden');
                listenStoryButton.classList.add('hidden'); // Hide listen button on error
            } finally {
                storyLoadingIndicator.classList.add('hidden'); // Hide loading indicator
            }
        });

        // Function to convert text to speech
        listenStoryButton.addEventListener('click', () => {
            const storyText = storyOutput.textContent;
            if (storyText && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(storyText);
                // Attempt to set the language to Saudi Arabic.
                // Note: Regional dialect support (like ar-SA) varies significantly across browsers and OS.
                // 'ar-SA' might not be specifically recognized, and a standard Arabic or general Arabic voice might be used instead.
                utterance.lang = 'ar-SA'; 

                // Find an Arabic voice if available
                const voices = window.speechSynthesis.getVoices();
                const arabicVoice = voices.find(voice => voice.lang === 'ar-SA' || voice.lang.startsWith('ar-') && voice.name.includes('Arabic'));
                if (arabicVoice) {
                    utterance.voice = arabicVoice;
                } else {
                    console.warn('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØµÙˆØª Ø¹Ø±Ø¨ÙŠ Ø³Ø¹ÙˆØ¯ÙŠ Ù…Ø­Ø¯Ø¯. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØµÙˆØª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø£Ùˆ Ø£ÙØ¶Ù„ ØµÙˆØª Ø¹Ø±Ø¨ÙŠ Ù…ØªØ§Ø­.');
                }

                window.speechSynthesis.speak(utterance);
            } else {
                console.error('Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ØµØ© Ø¨ØµÙˆØª Ø¹Ø§Ù„ÙØŒ Ø£Ùˆ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ØµØ© Ù„ØªØ´ØºÙŠÙ„Ù‡Ø§.');
                // You can display a message to the user here
            }
        });

        // AI Q&A Logic (Gemini API)
        askAiButton.addEventListener('click', async () => {
            const questionText = aiQuestionInput.value.trim();
            if (!questionText) {
                aiAnswerOutput.textContent = 'Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ø£ÙˆÙ„ Ø´ÙŠØ¡.';
                aiAnswerOutput.classList.remove('hidden');
                return;
            }

            aiLoadingIndicator.classList.remove('hidden');
            aiAnswerOutput.classList.add('hidden');
            aiAnswerOutput.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Ø£Ø¬Ø¨ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø³ÙŠØ·Ø© ÙˆÙ„Ø·ÙŠÙØ© ÙˆÙ…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø£Ø·ÙØ§Ù„ØŒ ÙˆØ¨Ø§Ù„Ù„Ù‡Ø¬Ø© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø©: ${questionText}.` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const answer = result.candidates[0].content.parts[0].text;
                    aiAnswerOutput.textContent = answer;
                    aiAnswerOutput.classList.remove('hidden');
                } else {
                    aiAnswerOutput.textContent = 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„Ùƒ. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©.';
                    aiAnswerOutput.classList.remove('hidden');
                    console.error('Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Gemini API:', result);
                }
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Gemini API Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©:', error);
                aiAnswerOutput.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„Ùƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ø£Ùˆ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.';
                aiAnswerOutput.classList.remove('hidden');
            } finally {
                aiLoadingIndicator.classList.add('hidden');
            }
        });


        // Tic-Tac-Toe Game Logic
        const ticTacToeBoard = document.getElementById('ticTacToeBoard');
        const ticTacToeCells = document.querySelectorAll('.tic-tac-toe-cell');
        const ticTacToeStatus = document.getElementById('ticTacToeStatus');
        const ticTacToeResetButton = document.getElementById('ticTacToeResetButton');

        let board = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X'; // Human player is 'X'
        const computerPlayer = 'O'; // AI player is 'O'
        let gameActive = true;
        let ticTacToeWinMessageIndex = 0;
        const ticTacToeWinMessages = [
            'Ø£Ø­Ø³Ù†Øª! ÙØ²Øª Ø¨Ø¬Ø¯Ø§Ø±Ø©! ğŸ‰',
            'ÙÙˆØ² Ø±Ø§Ø¦Ø¹! ğŸŒŸ',
            'Ù…Ø§ Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡! Ø¥ÙƒØ³ Ø£Ùˆ Ø­Ø±ÙƒØ§Øª! ÙØ²Øª! ğŸ†',
            'Ù…Ø¨Ø¯Ø¹! ÙÙˆØ² ÙˆÙ„Ø§ Ø£Ø±ÙˆØ¹! ğŸ’–',
            'Ù„Ø¹Ø¨Ùƒ Ù…Ù…ØªØ§Ø²! ÙØ²Øª! âœ¨'
        ];

        // Winning conditions for Tic-Tac-Toe
        const winningConditions = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6]
        ];

        // Function to handle cell clicks (human player)
        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.target;
            const clickedCellIndex = parseInt(clickedCell.getAttribute('data-cell-index'));

            // If the cell is already filled, game is inactive, or it's not human's turn, do nothing
            if (board[clickedCellIndex] !== '' || !gameActive || currentPlayer !== 'X') {
                return;
            }

            // Human player makes a move
            board[clickedCellIndex] = currentPlayer;
            clickedCell.textContent = currentPlayer;
            clickedCell.classList.add(currentPlayer.toLowerCase()); // Add class for styling X or O

            // Check game status after human's move
            if (handleResultValidation()) {
                return; // If game ends, stop
            }

            // Switch to computer's turn and make AI move after a short delay
            currentPlayer = computerPlayer;
            ticTacToeStatus.textContent = `Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± (O)`;
            setTimeout(makeAIMove, 700); // Add a small delay for AI move
        }

        // Function to make AI move
        function makeAIMove() {
            if (!gameActive) return;

            let bestMove = -1;
            let availableMoves = [];
            for (let i = 0; i < board.length; i++) {
                if (board[i] === '') {
                    availableMoves.push(i);
                }
            }

            // 1. Check if AI can win
            for (let i = 0; i < availableMoves.length; i++) {
                const move = availableMoves[i];
                board[move] = computerPlayer;
                if (checkWin(board, computerPlayer)) {
                    bestMove = move;
                    board[move] = ''; // Undo for checking other moves
                    break;
                }
                board[move] = ''; // Undo
            }

            // 2. Check if human can win and block them
            if (bestMove === -1) {
                for (let i = 0; i < availableMoves.length; i++) {
                    const move = availableMoves[i];
                    board[move] = 'X'; // Simulate opponent's move
                    if (checkWin(board, 'X')) {
                        bestMove = move;
                        board[move] = ''; // Undo
                        break;
                    }
                    board[move] = ''; // Undo
                }
            }

            // 3. Take center if available
            if (bestMove === -1 && board[4] === '') {
                bestMove = 4;
            }

            // 4. Take a corner if available
            if (bestMove === -1) {
                const corners = [0, 2, 6, 8];
                for (let i = 0; i < corners.length; i++) {
                    const corner = corners[i];
                    if (board[corner] === '') {
                        bestMove = corner;
                        break;
                    }
                }
            }

            // 5. Take any available side
            if (bestMove === -1) {
                const sides = [1, 3, 5, 7];
                for (let i = 0; i < sides.length; i++) {
                    const side = sides[i];
                    if (board[side] === '') {
                        bestMove = side;
                        break;
                    }
                }
            }

            // If no strategic move, pick a random available spot
            if (bestMove === -1 && availableMoves.length > 0) {
                bestMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
            
            // Apply the AI's chosen move
            if (bestMove !== -1) {
                board[bestMove] = computerPlayer;
                ticTacToeCells[bestMove].textContent = computerPlayer;
                ticTacToeCells[bestMove].classList.add(computerPlayer.toLowerCase());

                // Check game status after AI's move
                if (handleResultValidation()) {
                    return; // If game ends, stop
                }

                // Switch back to human player's turn
                currentPlayer = 'X';
                ticTacToeStatus.textContent = `Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ X`;
            } else {
                // This case should ideally not be reached if gameActive is true and board is not full
                console.error("AI couldn't find a move!");
            }
        }

        // Helper function to check for a win for a given player
        function checkWin(currentBoard, player) {
            for (let i = 0; i < winningConditions.length; i++) {
                const winCondition = winningConditions[i];
                let a = currentBoard[winCondition[0]];
                let b = currentBoard[winCondition[1]];
                let c = currentBoard[winCondition[2]];

                if (a === player && b === player && c === player) {
                    return true;
                }
            }
            return false;
        }

        // Function to validate game result
        function handleResultValidation() {
            // Check for a win for the current player
            if (checkWin(board, currentPlayer)) {
                if (currentPlayer === 'X') { // Human won
                    ticTacToeStatus.textContent = ticTacToeWinMessages[ticTacToeWinMessageIndex];
                    ticTacToeWinMessageIndex = (ticTacToeWinMessageIndex + 1) % ticTacToeWinMessages.length; // Cycle message
                } else { // Computer won
                    ticTacToeStatus.textContent = `Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙØ§Ø² Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©! ğŸ¤–`;
                }
                gameActive = false;
                return true;
            }

            // Check for a draw
            let roundDraw = !board.includes('');
            if (roundDraw) {
                ticTacToeStatus.textContent = 'ØªØ¹Ø§Ø¯Ù„! ğŸ¤';
                gameActive = false;
                return true;
            }
            return false; // Game is still active
        }

        // Function to reset the game
        function handleRestartGame() {
            gameActive = true;
            currentPlayer = 'X'; // Human player starts
            board = ['', '', '', '', '', '', '', '', ''];
            ticTacToeStatus.textContent = `Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ X`;
            ticTacToeCells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('x', 'o'); // Remove X/O styling classes
            });
        }

        // Add event listeners for Tic-Tac-Toe
        ticTacToeCells.forEach(cell => cell.addEventListener('click', handleCellClick));
        ticTacToeResetButton.addEventListener('click', handleRestartGame);

        // Rock-Paper-Scissors Game Logic
        const rpsChoices = document.querySelectorAll('.rps-choice-button');
        const rpsResult = document.getElementById('rpsResult');
        const rpsWinMessages = [
            'ÙØ²Øª! Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.',
            'Ø£Ø­Ø³Ù†Øª! ÙØ²Øª Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©! Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.',
            'ÙÙˆØ² Ø±Ø§Ø¦Ø¹! Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.'
        ];
        const rpsLoseMessages = [
            'Ø®Ø³Ø±Øª Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©! Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.',
            'Ø­Ø¸ Ø£ÙˆÙØ± Ø§Ù„Ù…Ø±Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©! Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.',
            'Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙØ§Ø² Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©. Ø£Ù†Øª Ø§Ø®ØªØ±Øª ${playerChoiceArabic} ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø§Ø®ØªØ§Ø± ${computerChoiceArabic}.'
        ];
        let rpsWinMessageIndex = 0;
        let rpsLoseMessageIndex = 0;

        // Function to play Rock-Paper-Scissors
        function playRPS(playerChoice) {
            const choices = ['rock', 'paper', 'scissors'];
            const computerChoice = choices[Math.floor(Math.random() * choices.length)];

            let result = '';
            const playerChoiceArabic = getArabicChoice(playerChoice);
            const computerChoiceArabic = getArabicChoice(computerChoice);

            // Determine the winner
            if (playerChoice === computerChoice) {
                result = `ØªØ¹Ø§Ø¯Ù„! ÙƒÙ„Ø§ÙƒÙ…Ø§ Ø§Ø®ØªØ§Ø± ${playerChoiceArabic}.`;
            } else if (
                (playerChoice === 'rock' && computerChoice === 'scissors') ||
                (playerChoice === 'paper' && computerChoice === 'rock') ||
                (playerChoice === 'scissors' && computerChoice === 'paper')
            ) {
                result = rpsWinMessages[rpsWinMessageIndex]
                    .replace('${playerChoiceArabic}', playerChoiceArabic)
                    .replace('${computerChoiceArabic}', computerChoiceArabic);
                rpsWinMessageIndex = (rpsWinMessageIndex + 1) % rpsWinMessages.length;
            } else {
                result = rpsLoseMessages[rpsLoseMessageIndex]
                    .replace('${playerChoiceArabic}', playerChoiceArabic)
                    .replace('${computerChoiceArabic}', computerChoiceArabic);
                rpsLoseMessageIndex = (rpsLoseMessageIndex + 1) % rpsLoseMessages.length;
            }
            rpsResult.textContent = result; // Display the result
        }

        // Helper function to get Arabic choice name
        function getArabicChoice(choice) {
            switch (choice) {
                case 'rock': return 'Ø­Ø¬Ø± âœŠ';
                case 'paper': return 'ÙˆØ±Ù‚Ø© âœ‹';
                case 'scissors': return 'Ù…Ù‚Øµ âœŒï¸';
                default: return '';
            }
        }

        // Add event listeners for Rock-Paper-Scissors buttons
        rpsChoices.forEach(button => {
            button.addEventListener('click', (e) => {
                const playerChoice = e.target.dataset.choice;
                playRPS(playerChoice);
            });
        });

        // Guess the Number Game Logic
        const guessInput = document.getElementById('guessInput');
        const guessButton = document.getElementById('guessButton');
        const guessMessage = document.getElementById('guessMessage');
        const guessCountDisplay = document.getElementById('guessCount');
        const guessResetButton = document.getElementById('guessResetButton');

        let secretNumber;
        let attempts;
        let gameEnded;
        let guessWinMessageIndex = 0;
        const guessWinMessages = [
            'Ø£Ø­Ø³Ù†Øª! Ø®Ù…Ù†Øª Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØµØ­ÙŠØ­ ÙÙŠ ${attempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸ‰',
            'Ù…Ù…ØªØ§Ø²! Ø¬Ø¨Øª Ø§Ù„Ø±Ù‚Ù… ØµØ­ ÙÙŠ ${attempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸŒŸ',
            'Ø±Ø§Ø¦Ø¹! Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø³Ø±ÙŠ Ù„Ù… ÙŠØ®Ù Ø¹Ù„ÙŠÙƒ! ÙÙˆØ² Ø±Ø§Ø¦Ø¹ ÙÙŠ ${attempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸ†'
        ];

        // Function to initialize the Guess the Number game
        function initializeGuessNumberGame() {
            secretNumber = Math.floor(Math.random() * 100) + 1; // Random number between 1 and 100
            attempts = 0;
            gameEnded = false;
            guessMessage.textContent = '';
            guessCountDisplay.textContent = 'Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: 0';
            guessInput.value = '';
            guessInput.disabled = false;
            guessButton.disabled = false;
            console.log('Secret Number (for debugging):', secretNumber); // For debugging
        }

        // Function to handle a guess
        function handleGuess() {
            if (gameEnded) return;

            const userGuess = parseInt(guessInput.value);

            if (isNaN(userGuess) || userGuess < 1 || userGuess > 100) {
                guessMessage.textContent = 'Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø¨ÙŠÙ† 1 Ùˆ 100.';
                return;
            }

            attempts++;
            guessCountDisplay.textContent = `Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: ${attempts}`;

            if (userGuess === secretNumber) {
                guessMessage.textContent = guessWinMessages[guessWinMessageIndex].replace('${attempts}', attempts).replace('${secretNumber}', secretNumber);
                guessWinMessageIndex = (guessWinMessageIndex + 1) % guessWinMessages.length;
                gameEnded = true;
                guessInput.disabled = true;
                guessButton.disabled = true;
            } else if (userGuess < secretNumber) {
                guessMessage.textContent = 'Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø³Ø±ÙŠ Ø£ÙƒØ¨Ø±. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
            } else {
                guessMessage.textContent = 'Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø³Ø±ÙŠ Ø£ØµØºØ±. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
            }
            guessInput.value = ''; // Clear input after guess
        }

        // Event listeners for Guess the Number game
        guessButton.addEventListener('click', handleGuess);
        guessInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleGuess();
            }
        });
        guessResetButton.addEventListener('click', initializeGuessNumberGame);

        // Memory Match Game Logic
        const memoryGrid = document.getElementById('memoryGrid');
        const memoryStatus = document.querySelector('.memory-status');
        const memoryResetButton = document.getElementById('memoryResetButton');

        const emojis = ['ğŸŒŸ', 'ğŸŒ™', 'ğŸ§¸', 'ğŸ’–', 'ğŸŒˆ', 'âœ¨', 'ğŸŒ¸', 'ğŸ¦‹']; // 8 unique emojis
        let cards = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let attemptsMade = 0;
        let lockBoard = false; // To prevent flipping more than two cards at once
        let memoryWinMessageIndex = 0;
        const memoryWinMessages = [
            'Ø£Ø­Ø³Ù†Øª! Ø£ÙƒÙ…Ù„Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ÙÙŠ ${attemptsMade} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸ‰',
            'Ø°Ø§ÙƒØ±ØªÙƒ Ù‚ÙˆÙŠØ©! Ø£Ø¨Ø¯Ø¹Øª ÙÙŠ ${attemptsMade} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸ§ ',
            'Ù…Ù…ØªØ§Ø²! ÙƒÙ„ Ø§Ù„Ø£Ø²ÙˆØ§Ø¬ ØµØ­ÙŠØ­Ø© ÙÙŠ ${attemptsMade} Ù…Ø­Ø§ÙˆÙ„Ø§Øª! ğŸ’–'
        ];


        // Function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Function to initialize the Memory Match game
        function initializeMemoryGame() {
            memoryGrid.innerHTML = ''; // Clear previous cards
            flippedCards = [];
            matchedPairs = 0;
            attemptsMade = 0;
            lockBoard = false;
            memoryStatus.textContent = 'Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: 0 | Ø§Ù„Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ØµØ­ÙŠØ­Ø©: 0';

            // Duplicate emojis to create pairs
            cards = [...emojis, ...emojis];
            shuffleArray(cards); // Shuffle the cards

            // Create card elements
            cards.forEach((emoji, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('memory-card');
                cardElement.dataset.emoji = emoji;
                cardElement.dataset.index = index;

                cardElement.innerHTML = `
                    <div class="card-face card-front">${emoji}</div>
                    <div class="card-face card-back"></div>
                `;
                cardElement.addEventListener('click', flipCard);
                memoryGrid.appendChild(cardElement);
            });
        }

        // Function to flip a card
        function flipCard() {
            if (lockBoard) return; // Prevent flipping if board is locked
            if (this === flippedCards[0]) return; // Prevent clicking the same card twice

            this.classList.add('flipped');
            flippedCards.push(this);

            if (flippedCards.length === 2) {
                attemptsMade++;
                memoryStatus.textContent = `Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: ${attemptsMade} | Ø§Ù„Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ØµØ­ÙŠØ­Ø©: ${matchedPairs}`;
                lockBoard = true; // Lock the board
                checkForMatch();
            }
        }

        // Function to check if two flipped cards match
        function checkForMatch() {
            const [card1, card2] = flippedCards;
            const isMatch = card1.dataset.emoji === card2.dataset.emoji;

            if (isMatch) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        // Function to disable matched cards
        function disableCards() {
            flippedCards[0].classList.add('matched');
            flippedCards[1].classList.add('matched');
            matchedPairs++;
            memoryStatus.textContent = `Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: ${attemptsMade} | Ø§Ù„Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ØµØ­ÙŠØ­Ø©: ${matchedPairs}`;

            resetFlippedCards();
            checkWinMemoryGame();
        }

        // Function to unflip non-matching cards
        function unflipCards() {
            setTimeout(() => {
                flippedCards[0].classList.remove('flipped');
                flippedCards[1].classList.remove('flipped');
                resetFlippedCards();
            }, 1000); // Wait 1 second before unflipping
        }

        // Function to reset flipped cards array and unlock board
        function resetFlippedCards() {
            [flippedCards[0], flippedCards[1]] = [null, null];
            flippedCards = [];
            lockBoard = false;
        }

        // Function to check if all pairs are matched
        function checkWinMemoryGame() {
            if (matchedPairs === emojis.length) {
                memoryStatus.textContent = memoryWinMessages[memoryWinMessageIndex].replace('${attemptsMade}', attemptsMade);
                memoryWinMessageIndex = (memoryWinMessageIndex + 1) % memoryWinMessages.length;
                gameActive = false; // Consider the game ended
            }
        }

        // Event listener for Memory Match reset button
        memoryResetButton.addEventListener('click', initializeMemoryGame);


        // Whack-a-Mole Game Logic
        const whackAMoleGrid = document.getElementById('whackAMoleGrid');
        const whackAMoleScoreDisplay = document.querySelector('.whack-a-mole-score');
        const whackAMoleTimeDisplay = document.querySelector('.whack-a-mole-time');
        const whackAMoleStartButton = document.getElementById('whackAMoleStartButton');
        const whackAMoleResetButton = document.getElementById('whackAMoleResetButton');

        const moleEmojis = ['ğŸ­', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ¸']; // Emojis for moles
        let score = 0;
        let timeRemaining = 30; // seconds
        let timerId;
        let moleInterval;
        let lastMoleHole;
        let gameRunning = false;
        let whackAMoleEndMessageIndex = 0;
        const whackAMoleEndMessages = [
            'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ø¬Ø¨Øª ${score} Ù†Ù‚Ø·Ø©! ğŸ†',
            'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! Ù†Ù‚Ø§Ø·Ùƒ: ${score}! âœ¨',
            'Ù„Ø¹Ø¨Øª Ø¬ÙŠØ¯Ø§Ù‹! Ø¬Ø¨Øª ${score} Ù†Ù‚Ø·Ø©! ğŸ‰'
        ];

        // Create mole holes dynamically
        function createMoleHoles() {
            whackAMoleGrid.innerHTML = ''; // Clear existing holes
            for (let i = 0; i < 9; i++) { // 3x3 grid
                const hole = document.createElement('div');
                hole.classList.add('mole-hole');
                const mole = document.createElement('div');
                mole.classList.add('mole-emoji');
                mole.textContent = moleEmojis[Math.floor(Math.random() * moleEmojis.length)]; // Assign random emoji
                mole.addEventListener('click', whackMole);
                hole.appendChild(mole);
                whackAMoleGrid.appendChild(hole);
            }
        }

        // Function to get a random hole
        function getRandomHole() {
            const holes = document.querySelectorAll('.mole-hole');
            const randomIndex = Math.floor(Math.random() * holes.length);
            const selectedHole = holes[randomIndex];

            if (selectedHole === lastMoleHole) {
                return getRandomHole(); // Avoid showing mole in the same hole twice in a row
            }
            lastMoleHole = selectedHole;
            return selectedHole;
        }

        // Function to show a mole
        function showMole() {
            const moles = document.querySelectorAll('.mole-emoji');
            moles.forEach(mole => mole.classList.remove('up')); // Hide all moles

            const randomHole = getRandomHole();
            const moleToShow = randomHole.querySelector('.mole-emoji');
            moleToShow.textContent = moleEmojis[Math.floor(Math.random() * moleEmojis.length)]; // Change emoji
            moleToShow.classList.add('up'); // Show the mole

            // Hide mole after a random time
            setTimeout(() => {
                moleToShow.classList.remove('up');
            }, Math.random() * 800 + 400); // Mole stays up for 0.4 to 1.2 seconds
        }

        // Function to whack a mole
        function whackMole(event) {
            if (!gameRunning) return;
            if (event.target.classList.contains('up')) {
                score++;
                whackAMoleScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                event.target.classList.remove('up'); // Hide the whacked mole immediately
            }
        }

        // Function to start the game timer
        function startGameTimer() {
            timeRemaining = 30;
            score = 0;
            whackAMoleScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
            whackAMoleTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${timeRemaining} Ø«Ø§Ù†ÙŠØ©`;
            gameRunning = true;

            timerId = setInterval(() => {
                timeRemaining--;
                whackAMoleTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${timeRemaining} Ø«Ø§Ù†ÙŠØ©`;

                if (timeRemaining <= 0) {
                    clearInterval(timerId);
                    clearInterval(moleInterval);
                    gameRunning = false;
                    whackAMoleTimeDisplay.textContent = `Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!`;
                    whackAMoleStartButton.classList.remove('hidden');
                    whackAMoleResetButton.classList.remove('hidden'); // Show reset button
                    alertUser(whackAMoleEndMessages[whackAMoleEndMessageIndex].replace('${score}', score));
                    whackAMoleEndMessageIndex = (whackAMoleEndMessageIndex + 1) % whackAMoleEndMessages.length;
                }
            }, 1000); // Update every second

            moleInterval = setInterval(showMole, 1000); // Moles appear every 1 second
            whackAMoleStartButton.classList.add('hidden');
            whackAMoleResetButton.classList.add('hidden'); // Hide reset button during game
        }

        // Function to reset Whack-a-Mole game
        function resetWhackAMoleGame() {
            clearInterval(timerId);
            clearInterval(moleInterval);
            gameRunning = false;
            score = 0;
            timeRemaining = 30;
            whackAMoleScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: 0`;
            whackAMoleTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: 30 Ø«Ø§Ù†ÙŠØ©`;
            const moles = document.querySelectorAll('.mole-emoji');
            moles.forEach(mole => mole.classList.remove('up'));
            whackAMoleStartButton.classList.remove('hidden');
            whackAMoleResetButton.classList.add('hidden');
        }

        // Custom alert function (instead of window.alert)
        function alertUser(message) {
            const alertBox = document.createElement('div');
            alertBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
                z-index: 1000;
                font-family: 'Cairo', sans-serif;
                font-size: 1.2rem;
                text-align: center;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 15px;
            `;
            alertBox.innerHTML = `
                <p>${message}</p>
                <button style="
                    background-color: #f8bbd0;
                    color: #332e40;
                    padding: 10px 20px;
                    border-radius: 9999px;
                    border: none;
                    cursor: pointer;
                    font-weight: 700;
                    transition: background-color 0.3s ease;
                ">Ù…ÙˆØ§ÙÙ‚</button>
            `;
            document.body.appendChild(alertBox);
            alertBox.querySelector('button').addEventListener('click', () => {
                document.body.removeChild(alertBox);
            });
        }


        // Event listeners for Whack-a-Mole
        whackAMoleStartButton.addEventListener('click', startGameTimer);
        whackAMoleResetButton.addEventListener('click', resetWhackAMoleGame);

        // Bubble Pop Game Logic
        const bubbleArea = document.getElementById('bubbleArea');
        const bubblePopScoreDisplay = document.querySelector('.bubble-pop-score');
        const bubblePopTimeDisplay = document.querySelector('.bubble-pop-time');
        const bubblePopStartButton = document.getElementById('bubblePopStartButton');
        const bubblePopResetButton = document.getElementById('bubblePopResetButton');

        let bubbleScore = 0;
        let bubbleTimeRemaining = 20; // seconds
        let bubbleTimerId;
        let bubbleIntervalId;
        let bubbleGameRunning = false;
        const bubbleEmojis = ['ğŸˆ', 'ğŸŒŸ', 'ğŸ’§', 'âœ¨', 'ğŸ’–', 'ğŸ«§']; // Emojis for bubbles
        let bubblePopEndMessageIndex = 0;
        const bubblePopEndMessages = [
            'Ø£Ø­Ø³Ù†Øª! ÙØ±Ù‚Ø¹Øª ${bubbleScore} ÙÙ‚Ø§Ø¹Ø©! ğŸ«§',
            'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! Ø¬Ø¨Øª ${bubbleScore} ÙÙ‚Ø§Ø¹Ø©! ğŸ‰',
            'Ù…Ù…ØªØ§Ø²! ÙØ±Ù‚Ø¹Øª ${bubbleScore} ÙÙ‚Ø§Ø¹Ø©! ğŸŒŸ'
        ];

        function createBubble() {
            if (!bubbleGameRunning) return;

            const bubble = document.createElement('div');
            bubble.classList.add('bubble');
            const size = Math.random() * 40 + 30; // Bubble size between 30px and 70px
            bubble.style.width = `${size}px`;
            bubble.style.height = `${size}px`;
            bubble.style.left = `${Math.random() * (bubbleArea.offsetWidth - size)}px`; // Random horizontal position
            bubble.style.animationDuration = `${Math.random() * 3 + 3}s`; // Animation duration 3-6 seconds
            bubble.style.animationDelay = `${Math.random() * 0.5}s`; // Slight delay for staggered appearance
            bubble.textContent = bubbleEmojis[Math.floor(Math.random() * bubbleEmojis.length)]; // Random emoji

            bubble.addEventListener('click', () => {
                if (bubbleGameRunning) {
                    bubbleScore++;
                    bubblePopScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${bubbleScore}`;
                    bubble.remove(); // Remove popped bubble
                }
            });

            bubbleArea.appendChild(bubble);

            // Remove bubble after animation ends to prevent accumulation
            bubble.addEventListener('animationend', () => {
                bubble.remove();
            });
        }

        function startBubblePopGame() {
            bubbleScore = 0;
            bubbleTimeRemaining = 20;
            bubblePopScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${bubbleScore}`;
            bubblePopTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${bubbleTimeRemaining} Ø«Ø§Ù†ÙŠØ©`;
            bubbleGameRunning = true;
            bubblePopStartButton.classList.add('hidden');
            bubblePopResetButton.classList.add('hidden');
            bubbleArea.innerHTML = ''; // Clear existing bubbles

            bubbleTimerId = setInterval(() => {
                bubbleTimeRemaining--;
                bubblePopTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: ${bubbleTimeRemaining} Ø«Ø§Ù†ÙŠØ©`;
                if (bubbleTimeRemaining <= 0) {
                    clearInterval(bubbleTimerId);
                    clearInterval(bubbleIntervalId);
                    bubbleGameRunning = false;
                    bubblePopTimeDisplay.textContent = `Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!`;
                    bubblePopStartButton.classList.remove('hidden');
                    bubblePopResetButton.classList.remove('hidden');
                    alertUser(bubblePopEndMessages[bubblePopEndMessageIndex].replace('${bubbleScore}', bubbleScore));
                    bubblePopEndMessageIndex = (bubblePopEndMessageIndex + 1) % bubblePopEndMessages.length;
                    // Remove all bubbles when game ends
                    document.querySelectorAll('.bubble').forEach(b => b.remove());
                }
            }, 1000);

            bubbleIntervalId = setInterval(createBubble, 500); // Create a new bubble every 0.5 seconds
        }

        function resetBubblePopGame() {
            clearInterval(bubbleTimerId);
            clearInterval(bubbleIntervalId);
            bubbleGameRunning = false;
            bubbleScore = 0;
            bubbleTimeRemaining = 20;
            bubblePopScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: 0`;
            bubblePopTimeDisplay.textContent = `Ø§Ù„ÙˆÙ‚Øª: 20 Ø«Ø§Ù†ÙŠØ©`;
            bubbleArea.innerHTML = ''; // Clear all bubbles
            bubblePopStartButton.classList.remove('hidden');
            bubblePopResetButton.classList.add('hidden');
        }

        bubblePopStartButton.addEventListener('click', startBubblePopGame);
        bubblePopResetButton.addEventListener('click', resetBubblePopGame);

        // Color Match Game Logic
        const targetColorDisplay = document.getElementById('targetColorDisplay');
        const colorChoicesGrid = document.getElementById('colorChoicesGrid');
        const colorMatchMessage = document.getElementById('colorMatchMessage');
        const colorMatchScoreDisplay = document.querySelector('.color-match-score');
        const colorMatchResetButton = document.getElementById('colorMatchResetButton');

        const colors = [
            '#FF6347', '#FFD700', '#6A5ACD', '#32CD32', '#FF69B4', // Tomato, Gold, SlateBlue, LimeGreen, HotPink
            '#1E90FF', '#FF4500', '#BA55D3', '#7FFF00', '#DC143C'  // DodgerBlue, OrangeRed, MediumPurple, Chartreuse, Crimson
        ];
        let currentColorIndex;
        let colorMatchScore = 0;
        let colorGameActive = false;
        let colorMatchWinMessageIndex = 0;
        const colorMatchWinMessages = [
            'Ø£Ø­Ø³Ù†Øª! ØµØ­ Ø¹Ù„ÙŠÙƒ! ğŸ¨',
            'Ù…Ø·Ø§Ø¨Ù‚Ø© Ø±Ø§Ø¦Ø¹Ø©! ğŸŒˆ',
            'Ù…Ù…ØªØ§Ø²! Ø¬Ø¨ØªÙ‡Ø§ ØµØ­! ğŸ’–'
        ];

        function getRandomColor() {
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function initializeColorMatchGame() {
            colorMatchScore = 0;
            colorMatchScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: 0`;
            colorMatchMessage.textContent = '';
            colorChoicesGrid.innerHTML = ''; // Clear previous choices
            colorGameActive = true;
            generateNewRound();
        }

        function generateNewRound() {
            if (!colorGameActive) return;

            colorChoicesGrid.innerHTML = '';
            colorMatchMessage.textContent = '';

            const targetColor = getRandomColor();
            targetColorDisplay.style.backgroundColor = targetColor;

            const choiceColors = [targetColor];
            while (choiceColors.length < 4) { // Generate 3 more distinct random colors
                const newColor = getRandomColor();
                if (!choiceColors.includes(newColor)) {
                    choiceColors.push(newColor);
                }
            }
            shuffleArray(choiceColors); // Shuffle choices

            choiceColors.forEach(color => {
                const button = document.createElement('button');
                button.classList.add('color-choice-button');
                button.style.backgroundColor = color;
                button.dataset.color = color;
                button.addEventListener('click', handleColorChoice);
                colorChoicesGrid.appendChild(button);
            });
        }

        function handleColorChoice(event) {
            if (!colorGameActive) return;

            const selectedColor = event.target.dataset.color;
            const targetColor = targetColorDisplay.style.backgroundColor;

            // Convert targetColor to hex if it's RGB (browser might return RGB)
            const rgbToHex = (rgb) => {
                const parts = rgb.match(/\d+/g);
                if (parts && parts.length >= 3) {
                    const toHex = (c) => ('0' + parseInt(c).toString(16)).slice(-2);
                    return '#' + toHex(parts[0]) + toHex(parts[1]) + toHex(parts[2]).toUpperCase();
                }
                return rgb; // Return as is if not in expected RGB format
            };

            const targetColorHex = targetColor.startsWith('rgb') ? rgbToHex(targetColor) : targetColor;

            if (selectedColor.toUpperCase() === targetColorHex.toUpperCase()) {
                colorMatchScore++;
                colorMatchScoreDisplay.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${colorMatchScore}`;
                colorMatchMessage.textContent = colorMatchWinMessages[colorMatchWinMessageIndex];
                colorMatchWinMessageIndex = (colorMatchWinMessageIndex + 1) % colorMatchWinMessages.length;
                setTimeout(generateNewRound, 1000); // Next round after 1 second
            } else {
                colorMatchMessage.textContent = 'Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©.';
            }
        }

        colorMatchResetButton.addEventListener('click', initializeColorMatchGame);


        // Initial setup on window load
        window.onload = function() {
            console.log('Ø§Ù„ØµÙØ­Ø© Ø¬Ø§Ù‡Ø²Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„ØªØ´ØºÙŠÙ„.');
            initializeGuessNumberGame(); // Initialize Guess the Number game on load
            initializeMemoryGame(); // Initialize Memory Match game on load
            createMoleHoles(); // Create mole holes for Whack-a-Mole
            initializeColorMatchGame(); // Initialize Color Match game on load
            // Bubble Pop game starts with a button click, no initial setup needed here
        };
    </script>
</body>
</html>
